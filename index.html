<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Model Viewer</title>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; position: relative; background-color: #111; background-image: url('pokemonBackground.gif'); background-size: cover; background-position: center; background-repeat: no-repeat; }
    #ui {
      position: fixed; left: 12px; top: 12px; z-index: 10;
      color: #fff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: rgba(0,0,0,0.55); padding: 10px 12px; border-radius: 10px;
      backdrop-filter: blur(6px);
      max-width: calc(100vw - 24px);
    }
    #ui h1 { font-size: 14px; margin: 0 0 6px 0; font-weight: 600; }
    #ui .row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; margin-bottom: 6px; }
    #ui button {
      border: 0; border-radius: 8px; padding: 8px 10px;
      background: #2b2b2b; color: #fff; cursor: pointer;
    }
    #ui button:hover { background: #3a3a3a; }
    #ui button:disabled { background: #1a1a1a; color: #666; cursor: not-allowed; }
    #ui label { font-size: 12px; opacity: 0.9; display: flex; gap: 6px; align-items: center; }
    #ui input[type="range"] { width: 140px; }
    #modelCounter { font-size: 12px; opacity: 0.8; }
    #msg {
      position: fixed; inset: 0; display: grid; place-items: center;
      color: #ddd; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    canvas { display: block; position: absolute; top: 0; left: 0; z-index: 2; }

    /* Menu Styles */
    #menuButton { position: fixed; top: 12px; right: 12px; z-index: 11; }
    #menuPanel {
      position: fixed; inset: 0; background: rgba(0,0,0,0.8); z-index: 12;
      display: none; flex-direction: column; padding: 20px; overflow-y: auto;
    }
    #menuClose { align-self: flex-end; margin-bottom: 10px; }
    #menuGrid {
      display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 10px;
    }
    .menuTile {
      background: none; border-radius: 8px; padding: 0; cursor: pointer; text-align: center;
    }
    .menuTile img { width: 100%; height: auto; border-radius: 8px; object-fit: contain; background: #1a1a1a; }
    .menuTile span { display: none; }
    .menuTile:hover img { filter: brightness(1.1); }
    .menuTile.selected img { box-shadow: 0 0 0 2px #fff; }
  </style>
</head>
<body>
  <div id="ui">
    <h1>3D Model Viewer</h1>
    <div class="row">
      <span id="modelCounter">Model 1 of 1</span>
    </div>
    <div class="row">
      <button id="reset">Reset View</button>
      <button id="toggleRotate">Auto-rotate: OFF</button>
      <button id="toggleModel">Hide Model</button>
      <label>Speed <input id="speed" type="range" min="0" max="2" step="0.01" value="0.6"></label>
    </div>
  </div>

  <button id="menuButton">☰ Menu</button>

  <div id="menuPanel">
    <button id="menuClose">Close</button>
    <div id="menuGrid"></div>
  </div>

  <div id="msg">Loading models…</div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script>
    let MODEL_FILES = [];
    let currentModelIndex = 0;
    let currentSound = null; 
    let showModel = true;

    const msg = document.getElementById("msg");
    const menuPanel = document.getElementById("menuPanel");
    const menuGrid = document.getElementById("menuGrid");
    const menuButton = document.getElementById("menuButton");
    const menuClose = document.getElementById("menuClose");

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.01, 2000);
    camera.position.set(2.5, 1.7, 2.5);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();
    const textureLoader = new THREE.TextureLoader();

    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    let rotation = { x: 0.3, y: 0.8 };
    let targetRotation = { x: 0.3, y: 0.8 };
    let cameraRadius = 5;
    let cameraTarget = new THREE.Vector3(0, 0, 0);

    renderer.domElement.addEventListener('mousedown', (e) => {
      isDragging = true;
      previousMousePosition = { x: e.clientX, y: e.clientY };
    });

    renderer.domElement.addEventListener('mousemove', (e) => {
      if (isDragging) {
        const deltaX = e.clientX - previousMousePosition.x;
        const deltaY = e.clientY - previousMousePosition.y;
        targetRotation.y += deltaX * 0.005;
        targetRotation.x += deltaY * 0.005;
        targetRotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetRotation.x));
        previousMousePosition = { x: e.clientX, y: e.clientY };
      }
    });

    renderer.domElement.addEventListener('mouseup', (e) => {
      isDragging = false;
      handleClick(e);
    });

    renderer.domElement.addEventListener('wheel', (e) => {
      e.preventDefault();
      cameraRadius += e.deltaY * 0.01;
      cameraRadius = Math.max(0.5, Math.min(100, cameraRadius));
    });

    function updateCamera() {
      rotation.x += (targetRotation.x - rotation.x) * 0.1;
      rotation.y += (targetRotation.y - rotation.y) * 0.1;
      camera.position.x = cameraTarget.x + cameraRadius * Math.cos(rotation.x) * Math.sin(rotation.y);
      camera.position.y = cameraTarget.y + cameraRadius * Math.sin(rotation.x);
      camera.position.z = cameraTarget.z + cameraRadius * Math.cos(rotation.x) * Math.cos(rotation.y);
      camera.lookAt(cameraTarget);
    }

    const hemi = new THREE.HemisphereLight(0xffffff, 0x222233, 1.0);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffffff, 1.2);
    dir.position.set(3, 6, 4);
    scene.add(dir);

    const loader = new THREE.GLTFLoader();
    let pivot = null;

    async function loadModel(filename) {
      msg.style.display = 'grid';
      msg.textContent = 'Loading model…';
      if (pivot) { scene.remove(pivot); pivot = null; }

      try {
        const gltf = await loader.loadAsync(filename);
        const modelRoot = gltf.scene;
        const box = new THREE.Box3().setFromObject(modelRoot);
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());

        modelRoot.position.x = -center.x;
        modelRoot.position.y = -center.y;
        modelRoot.position.z = -center.z;

        pivot = new THREE.Group();
        pivot.add(modelRoot);
        scene.add(pivot);

        const maxDim = Math.max(size.x, size.y, size.z);
        cameraRadius = maxDim * 2.5;
        targetRotation = { x: 0.3, y: 0.8 };
        rotation = { x: 0.3, y: 0.8 };

        loadSound(filename);
        msg.style.display = "none";
        updateModelCounter();
        highlightSelectedTile();
      } catch (err) {
        msg.textContent = `Failed to load ${filename}.`;
      }
    }

    async function loadCard(filename) {
      msg.style.display = 'grid';
      msg.textContent = 'Loading card…';
      if (pivot) { scene.remove(pivot); pivot = null; }

      const frontUrl = getThumbnailUrl(filename);
      const backUrl = 'models/thumbnails/cardbacking.png';

      try {
        const [frontTexture, backTexture] = await Promise.all([
          textureLoader.loadAsync(frontUrl),
          textureLoader.loadAsync(backUrl)
        ]);

        // Dynamically calculate aspect ratio from the front image
        const aspect = frontTexture.image.width / frontTexture.image.height;
        const cardWidth = 1;
        const cardHeight = cardWidth / aspect;

        // Use a BoxGeometry for physical thickness and identical sizing
        const geometry = new THREE.BoxGeometry(cardWidth, cardHeight, 0.02);
        
        // Correct for the back texture being mirrored by rotating it 180 deg
        backTexture.center.set(0.5, 0.5);
        backTexture.rotation = Math.PI;

        // Material Array: [Right, Left, Top, Bottom, Front, Back]
        const materials = [
          new THREE.MeshBasicMaterial({ color: 0x222222 }), // Edge
          new THREE.MeshBasicMaterial({ color: 0x222222 }), // Edge
          new THREE.MeshBasicMaterial({ color: 0x222222 }), // Edge
          new THREE.MeshBasicMaterial({ color: 0x222222 }), // Edge
          new THREE.MeshBasicMaterial({ map: frontTexture }), // Front
          new THREE.MeshBasicMaterial({ map: backTexture })  // Back
        ];

        const cardMesh = new THREE.Mesh(geometry, materials);
        pivot = new THREE.Group();
        pivot.add(cardMesh);
        scene.add(pivot);

        cameraRadius = cardHeight * 2;
        targetRotation = { x: 0.3, y: 0.8 };
        rotation = { x: 0.3, y: 0.8 };

        if (currentSound) { currentSound.pause(); currentSound = null; }

        msg.style.display = "none";
        updateModelCounter();
        highlightSelectedTile();
      } catch (err) {
        msg.textContent = `Failed to load card.`;
      }
    }

    async function loadCurrent() {
      const filename = MODEL_FILES[currentModelIndex];
      if (showModel) { await loadModel(filename); } 
      else { await loadCard(filename); }
    }

    function loadSound(modelFilename) {
      if (currentSound) { currentSound.pause(); currentSound = null; }
      const baseName = modelFilename.split('/').pop().replace('.glb', '');
      const soundUrl = `sounds/${baseName}.mp3`;
      currentSound = new Audio(soundUrl);
    }

    function playSound() {
      if (currentSound) {
        currentSound.currentTime = 0;
        currentSound.play().catch(() => {});
      }
    }

    function handleClick(event) {
      if (!showModel) return;
      pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
      pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(pointer, camera);
      const intersects = raycaster.intersectObjects(scene.children, true);
      if (intersects.length > 0) playSound();
    }

    function updateModelCounter() {
      document.getElementById('modelCounter').textContent =
        `${getDisplayName(MODEL_FILES[currentModelIndex])} (${currentModelIndex + 1} of ${MODEL_FILES.length})`;
    }

    function getDisplayName(filename) {
      const name = filename.split('/').pop().replace('.glb', '');
      return name.replace(/[-_]/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
    }

    function getThumbnailUrl(glbFilename) {
      const baseName = glbFilename.split('/').pop().replace('.glb', '');
      return `models/thumbnails/${baseName}.jpg`;
    }

    async function init() {
      try {
        const response = await fetch('https://api.github.com/repos/pneumatic-steel/3D-viewer/contents/models');
        const data = await response.json();
        MODEL_FILES = data
          .filter(item => item.type === 'file' && item.name.toLowerCase().endsWith('.glb'))
          .map(item => `models/${item.name}`)
          .sort((a, b) => a.localeCompare(b));

        buildMenu();
        await loadCurrent();
      } catch (error) {
        msg.textContent = 'Failed to fetch model list.';
      }
    }

    function buildMenu() {
      menuGrid.innerHTML = '';
      MODEL_FILES.forEach((filename, index) => {
        const tile = document.createElement('div');
        tile.className = 'menuTile';
        if (index === currentModelIndex) tile.classList.add('selected');
        const img = document.createElement('img');
        img.src = getThumbnailUrl(filename);
        tile.appendChild(img);
        tile.addEventListener('click', async () => {
          currentModelIndex = index;
          await loadCurrent();
          menuPanel.style.display = 'none';
        });
        menuGrid.appendChild(tile);
      });
    }

    function highlightSelectedTile() {
      document.querySelectorAll('.menuTile').forEach((tile, i) => {
        tile.classList.toggle('selected', i === currentModelIndex);
      });
      updateModelCounter();
    }

    menuButton.addEventListener('click', () => { menuPanel.style.display = 'flex'; buildMenu(); });
    menuClose.addEventListener('click', () => { menuPanel.style.display = 'none'; });

    let autoRotate = false;
    const btnRotate = document.getElementById("toggleRotate");
    const btnReset = document.getElementById("reset");
    const btnToggleModel = document.getElementById("toggleModel");
    const speed = document.getElementById("speed");

    btnRotate.addEventListener("click", () => {
      autoRotate = !autoRotate;
      btnRotate.textContent = `Auto-rotate: ${autoRotate ? "ON" : "OFF"}`;
    });

    btnReset.addEventListener("click", () => {
      targetRotation = { x: 0.3, y: 0.8 };
      rotation = { x: 0.3, y: 0.8 };
    });

    btnToggleModel.addEventListener("click", () => {
      showModel = !showModel;
      btnToggleModel.textContent = showModel ? "Hide Model" : "Show Model";
      loadCurrent();
    });

    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      updateCamera();
      if (pivot && autoRotate && !isDragging) {
        pivot.rotation.y += clock.getDelta() * parseFloat(speed.value);
      }
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    init();
  </script>
</body>
</html>
