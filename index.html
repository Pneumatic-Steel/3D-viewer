<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Model Viewer</title>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; position: relative; background-color: #111; background-image: url('pokemonBackground.gif'); background-size: cover; background-position: center; background-repeat: no-repeat; }
    #ui {
      position: fixed; left: 12px; top: 12px; z-index: 10;
      color: #fff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: rgba(0,0,0,0.55); padding: 10px 12px; border-radius: 10px;
      backdrop-filter: blur(6px);
      max-width: calc(100vw - 24px);
    }
    #ui h1 { font-size: 14px; margin: 0 0 6px 0; font-weight: 600; }
    #ui .row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; margin-bottom: 6px; }
    #ui button {
      border: 0; border-radius: 8px; padding: 8px 10px;
      background: #2b2b2b; color: #fff; cursor: pointer;
    }
    #ui button:hover { background: #3a3a3a; }
    #ui button:disabled { background: #1a1a1a; color: #666; cursor: not-allowed; }
    #ui label { font-size: 12px; opacity: 0.9; display: flex; gap: 6px; align-items: center; }
    #ui input[type="range"] { width: 140px; }
    #modelCounter { font-size: 12px; opacity: 0.8; }
    #msg {
      position: fixed; inset: 0; display: grid; place-items: center;
      color: #ddd; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    canvas { display: block; position: absolute; top: 0; left: 0; z-index: 2; }

    /* Menu Styles */
    #menuButton { position: fixed; top: 12px; right: 12px; z-index: 11; }
    #menuPanel {
      position: fixed; inset: 0; background: rgba(0,0,0,0.8); z-index: 12;
      display: none; flex-direction: column; padding: 20px; overflow-y: auto;
    }
    #menuClose { align-self: flex-end; margin-bottom: 10px; }
    #menuGrid {
      display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 10px;
    }
    .menuTile {
      background: none; border-radius: 8px; padding: 0; cursor: pointer; text-align: center;
    }
    .menuTile img { width: 100%; height: auto; border-radius: 8px; object-fit: contain; background: #1a1a1a; }
    .menuTile:hover img { filter: brightness(1.1); }
    .menuTile.selected img { box-shadow: 0 0 0 2px #fff; }
  </style>
</head>
<body>
  <div id="ui">
    <h1>3D Model Viewer</h1>
    <div class="row">
      <span id="modelCounter">Model 1 of 1</span>
    </div>
    <div class="row">
      <button id="reset">Reset View</button>
      <button id="toggleRotate">Auto-rotate: OFF</button>
      <button id="toggleModel">Hide Model</button>
      <label>Speed <input id="speed" type="range" min="0" max="2" step="0.01" value="0.6"></label>
    </div>
  </div>

  <button id="menuButton">☰ Menu</button>

  <div id="menuPanel">
    <button id="menuClose">Close</button>
    <div id="menuGrid"></div>
  </div>

  <div id="msg">Loading models…</div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script>
    let MODEL_FILES = [];
    let currentModelIndex = 0;
    let currentSound = null; 
    let showModel = true;

    const msg = document.getElementById("msg");
    const menuPanel = document.getElementById("menuPanel");
    const menuGrid = document.getElementById("menuGrid");
    const menuButton = document.getElementById("menuButton");
    const menuClose = document.getElementById("menuClose");

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.01, 2000);
    camera.position.set(2.5, 1.7, 2.5);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();
    const textureLoader = new THREE.TextureLoader();

    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    let rotation = { x: 0.3, y: 0.8 };
    let targetRotation = { x: 0.3, y: 0.8 };
    let cameraRadius = 5;
    let cameraTarget = new THREE.Vector3(0, 0, 0);

    // Mouse and Touch events (kept from original for functionality)
    renderer.domElement.addEventListener('mousedown', (e) => { isDragging = true; previousMousePosition = { x: e.clientX, y: e.clientY }; });
    renderer.domElement.addEventListener('mousemove', (e) => {
      if (isDragging) {
        const deltaX = e.clientX - previousMousePosition.x;
        const deltaY = e.clientY - previousMousePosition.y;
        targetRotation.y += deltaX * 0.005;
        targetRotation.x += deltaY * 0.005;
        targetRotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetRotation.x));
        previousMousePosition = { x: e.clientX, y: e.clientY };
      }
    });
    renderer.domElement.addEventListener('mouseup', (e) => { isDragging = false; handleClick(e); });
    renderer.domElement.addEventListener('wheel', (e) => { e.preventDefault(); cameraRadius += e.deltaY * 0.01; cameraRadius = Math.max(0.5, Math.min(100, cameraRadius)); });

    function updateCamera() {
      rotation.x += (targetRotation.x - rotation.x) * 0.1;
      rotation.y += (targetRotation.y - rotation.y) * 0.1;
      camera.position.x = cameraTarget.x + cameraRadius * Math.cos(rotation.x) * Math.sin(rotation.y);
      camera.position.y = cameraTarget.y + cameraRadius * Math.sin(rotation.x);
      camera.position.z = cameraTarget.z + cameraRadius * Math.cos(rotation.x) * Math.cos(rotation.y);
      camera.lookAt(cameraTarget);
    }

    const hemi = new THREE.HemisphereLight(0xffffff, 0x222233, 1.0);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 1.2);
    dir.position.set(3, 6, 4);
    scene.add(dir);

    const loader = new THREE.GLTFLoader();
    let pivot = null;

    async function loadModel(filename) {
      msg.style.display = 'grid';
      msg.textContent = 'Loading model…';
      if (pivot) { scene.remove(pivot); pivot = null; }

      try {
        const gltf = await loader.loadAsync(filename);
        const modelRoot = gltf.scene;
        const box = new THREE.Box3().setFromObject(modelRoot);
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());
        modelRoot.position.sub(center);
        pivot = new THREE.Group();
        pivot.add(modelRoot);
        scene.add(pivot);
        cameraRadius = Math.max(size.x, size.y, size.z) * 2.5;
        loadSound(filename);
        msg.style.display = "none";
        updateModelCounter();
        highlightSelectedTile();
      } catch (err) { msg.textContent = 'Error loading model.'; }
    }

    async function loadCard(filename) {
      msg.style.display = 'grid';
      msg.textContent = 'Loading card…';
      if (pivot) { scene.remove(pivot); pivot = null; }

      const frontUrl = getThumbnailUrl(filename);
      const backUrl = 'models/thumbnails/cardbacking.png';

      try {
        const [frontTex, backTex] = await Promise.all([
          textureLoader.loadAsync(frontUrl),
          textureLoader.loadAsync(backUrl)
        ]);

        // Get aspect ratio from the front image
        const aspect = frontTex.image.width / frontTex.image.height;
        const w = 2.5; 
        const h = w / aspect;

        // Create one geometry used by BOTH front and back
        const geo = new THREE.PlaneGeometry(w, h);

        // Front Mesh
        const frontMesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ map: frontTex, side: THREE.FrontSide }));
        
        // Back Mesh - Same geometry, flipped 180 and pushed back a tiny bit (slapped together)
        const backMesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ map: backTex, side: THREE.FrontSide }));
        backMesh.rotation.y = Math.PI;
        backMesh.position.z = -0.01; // The "glue" gap

        pivot = new THREE.Group();
        pivot.add(frontMesh);
        pivot.add(backMesh);
        scene.add(pivot);

        cameraRadius = h * 1.5;
        targetRotation = { x: 0, y: 0 };
        
        msg.style.display = "none";
        updateModelCounter();
        highlightSelectedTile();
      } catch (err) { msg.textContent = 'Error loading card images.'; }
    }

    async function loadCurrent() {
      const filename = MODEL_FILES[currentModelIndex];
      showModel ? await loadModel(filename) : await loadCard(filename);
    }

    function loadSound(modelFilename) {
      if (currentSound) { currentSound.pause(); currentSound = null; }
      const baseName = modelFilename.split('/').pop().replace('.glb', '');
      currentSound = new Audio(`sounds/${baseName}.mp3`);
    }

    function playSound() { if (currentSound) { currentSound.currentTime = 0; currentSound.play().catch(() => {}); } }

    function handleClick(event) {
      if (!showModel) return;
      pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
      pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(pointer, camera);
      const intersects = raycaster.intersectObjects(scene.children, true);
      if (intersects.length > 0) playSound();
    }

    function updateModelCounter() {
      const filename = MODEL_FILES[currentModelIndex];
      document.getElementById('modelCounter').textContent = 
        `${getDisplayName(filename)} (${currentModelIndex + 1} of ${MODEL_FILES.length})`;
    }

    function getDisplayName(f) { return f.split('/').pop().replace('.glb', '').replace(/[-_]/g, ' ').toUpperCase(); }
    function getThumbnailUrl(f) { return `models/thumbnails/${f.split('/').pop().replace('.glb', '')}.jpg`; }

    async function init() {
      try {
        const res = await fetch('https://api.github.com/repos/pneumatic-steel/3D-viewer/contents/models');
        const data = await res.json();
        MODEL_FILES = data.filter(i => i.name.endsWith('.glb')).map(i => `models/${i.name}`).sort();
        buildMenu();
        await loadCurrent();
      } catch (e) { msg.textContent = 'Load failed.'; }
    }

    function buildMenu() {
      menuGrid.innerHTML = '';
      MODEL_FILES.forEach((f, i) => {
        const tile = document.createElement('div');
        tile.className = 'menuTile';
        if (i === currentModelIndex) tile.classList.add('selected');
        const img = document.createElement('img');
        img.src = getThumbnailUrl(f);
        tile.appendChild(img);
        tile.onclick = async () => { currentModelIndex = i; await loadCurrent(); menuPanel.style.display = 'none'; };
        menuGrid.appendChild(tile);
      });
    }

    function highlightSelectedTile() {
      document.querySelectorAll('.menuTile').forEach((t, i) => t.classList.toggle('selected', i === currentModelIndex));
      updateModelCounter();
    }

    menuButton.onclick = () => { menuPanel.style.display = 'flex'; buildMenu(); };
    menuClose.onclick = () => { menuPanel.style.display = 'none'; };

    let autoRotate = false;
    const btnRotate = document.getElementById("toggleRotate");
    const speed = document.getElementById("speed");

    btnRotate.onclick = () => { autoRotate = !autoRotate; btnRotate.textContent = `Auto-rotate: ${autoRotate ? "ON" : "OFF"}`; };
    document.getElementById("reset").onclick = () => { targetRotation = { x: 0.3, y: 0.8 }; };
    document.getElementById("toggleModel").onclick = () => { 
      showModel = !showModel; 
      document.getElementById("toggleModel").textContent = showModel ? "Hide Model" : "Show Model"; 
      loadCurrent(); 
    };

    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      updateCamera();
      if (pivot && autoRotate && !isDragging) pivot.rotation.y += clock.getDelta() * parseFloat(speed.value);
      renderer.render(scene, camera);
    }
    animate();
    window.onresize = () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); };
    init();
  </script>
</body>
</html>
