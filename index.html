<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Model Viewer</title>
  <style>
    html, body { height: 100%; margin: 0; background: #111; overflow: hidden; }
    #ui {
      position: fixed; left: 12px; top: 12px; z-index: 10;
      color: #fff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: rgba(0,0,0,0.55); padding: 10px 12px; border-radius: 10px;
      backdrop-filter: blur(6px);
      max-width: calc(100vw - 24px);
    }
    #ui h1 { font-size: 14px; margin: 0 0 6px 0; font-weight: 600; }
    #ui .row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; margin-bottom: 6px; }
    #ui button {
      border: 0; border-radius: 8px; padding: 8px 10px;
      background: #2b2b2b; color: #fff; cursor: pointer;
    }
    #ui button:hover { background: #3a3a3a; }
    #ui button:disabled { background: #1a1a1a; color: #666; cursor: not-allowed; }
    #ui label { font-size: 12px; opacity: 0.9; display: flex; gap: 6px; align-items: center; }
    #ui input[type="range"] { width: 140px; }
    #modelCounter { font-size: 12px; opacity: 0.8; }
    #msg {
      position: fixed; inset: 0; display: grid; place-items: center;
      color: #ddd; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    canvas { display: block; }

    /* Menu Styles */
    #menuButton { position: fixed; top: 12px; right: 12px; z-index: 11; }
    #menuPanel {
      position: fixed; inset: 0; background: rgba(0,0,0,0.8); z-index: 12;
      display: none; flex-direction: column; padding: 20px; overflow-y: auto;
    }
    #menuClose { align-self: flex-end; margin-bottom: 10px; }
    #menuGrid {
      display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 10px;
    }
    .menuTile {
      background: #2b2b2b; border-radius: 8px; padding: 8px; cursor: pointer; text-align: center;
    }
    .menuTile img { width: 100%; height: auto; border-radius: 4px; object-fit: cover; aspect-ratio: 1/1; background: #1a1a1a; }
    .menuTile span { display: block; margin-top: 4px; font-size: 12px; }
    .menuTile:hover { background: #3a3a3a; }
    .menuTile.selected { border: 2px solid #fff; }
  </style>
</head>
<body>
  <div id="ui">
    <h1>3D Model Viewer</h1>
    <div class="row">
      <span id="modelCounter">Model 1 of 1</span>
    </div>
    <div class="row">
      <button id="reset">Reset View</button>
      <button id="toggleRotate">Auto-rotate: ON</button>
      <label>Speed <input id="speed" type="range" min="0" max="2" step="0.01" value="0.6"></label>
    </div>
  </div>

  <button id="menuButton">☰ Menu</button>

  <div id="menuPanel">
    <button id="menuClose">Close</button>
    <div id="menuGrid"></div>
  </div>

  <div id="msg">Loading models…</div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script>
    let MODEL_FILES = [];
    let currentModelIndex = 0;
    let currentSound = null; // Current audio element

    const msg = document.getElementById("msg");
    const menuPanel = document.getElementById("menuPanel");
    const menuGrid = document.getElementById("menuGrid");
    const menuButton = document.getElementById("menuButton");
    const menuClose = document.getElementById("menuClose");

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);

    const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.01, 2000);
    camera.position.set(2.5, 1.7, 2.5);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    // Basic orbit controls implementation
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    let rotation = { x: 0.3, y: 0.8 };
    let targetRotation = { x: 0.3, y: 0.8 };
    let cameraRadius = 5;
    let cameraTarget = new THREE.Vector3(0, 0, 0);

    // Mouse controls
    renderer.domElement.addEventListener('mousedown', (e) => {
      isDragging = true;
      previousMousePosition = { x: e.clientX, y: e.clientY };
    });

    renderer.domElement.addEventListener('mousemove', (e) => {
      if (isDragging) {
        const deltaX = e.clientX - previousMousePosition.x;
        const deltaY = e.clientY - previousMousePosition.y;

        targetRotation.y += deltaX * 0.005;
        targetRotation.x += deltaY * 0.005;
        targetRotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetRotation.x));

        previousMousePosition = { x: e.clientX, y: e.clientY };
      }
    });

    renderer.domElement.addEventListener('mouseup', (e) => {
      isDragging = false;
      handleClick(e); // Check for model click after drag ends
    });

    renderer.domElement.addEventListener('mouseleave', () => {
      isDragging = false;
    });

    renderer.domElement.addEventListener('wheel', (e) => {
      e.preventDefault();
      cameraRadius += e.deltaY * 0.01;
      cameraRadius = Math.max(0.5, Math.min(100, cameraRadius));
    });

    // Touch controls
    let lastTouchDistance = 0;

    renderer.domElement.addEventListener('touchstart', (e) => {
      e.preventDefault();
      if (e.touches.length === 1) {
        isDragging = true;
        previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      } else if (e.touches.length === 2) {
        isDragging = false;
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
      }
    });

    renderer.domElement.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (e.touches.length === 1 && isDragging) {
        const deltaX = e.touches[0].clientX - previousMousePosition.x;
        const deltaY = e.touches[0].clientY - previousMousePosition.y;

        targetRotation.y += deltaX * 0.005;
        targetRotation.x += deltaY * 0.005;
        targetRotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetRotation.x));

        previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      } else if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (lastTouchDistance > 0) {
          const delta = lastTouchDistance - distance;
          cameraRadius += delta * 0.05;
          cameraRadius = Math.max(0.5, Math.min(100, cameraRadius));
        }

        lastTouchDistance = distance;
      }
    });

    renderer.domElement.addEventListener('touchend', (e) => {
      e.preventDefault();
      isDragging = false;
      lastTouchDistance = 0;
      if (e.changedTouches.length === 1) {
        handleClick(e.changedTouches[0]); // Treat as click
      }
    });

    function updateCamera() {
      rotation.x += (targetRotation.x - rotation.x) * 0.1;
      rotation.y += (targetRotation.y - rotation.y) * 0.1;

      camera.position.x = cameraTarget.x + cameraRadius * Math.cos(rotation.x) * Math.sin(rotation.y);
      camera.position.y = cameraTarget.y + cameraRadius * Math.sin(rotation.x);
      camera.position.z = cameraTarget.z + cameraRadius * Math.cos(rotation.x) * Math.cos(rotation.y);
      camera.lookAt(cameraTarget);
    }

    // Lights
    const hemi = new THREE.HemisphereLight(0xffffff, 0x222233, 1.0);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffffff, 1.2);
    dir.position.set(3, 6, 4);
    scene.add(dir);

    // Model loading
    const loader = new THREE.GLTFLoader();
    let pivot = null;

    async function loadModel(filename) {
      msg.style.display = 'grid';
      msg.textContent = 'Loading model…';

      if (pivot) {
        scene.remove(pivot);
        pivot = null;
      }

      try {
        const gltf = await loader.loadAsync(filename);
        const modelRoot = gltf.scene;

        const box = new THREE.Box3().setFromObject(modelRoot);
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());

        modelRoot.position.x = -center.x;
        modelRoot.position.y = -center.y;
        modelRoot.position.z = -center.z;

        // Optional: modelRoot.position.y += size.y / 2;

        pivot = new THREE.Group();
        pivot.add(modelRoot);
        scene.add(pivot);

        const maxDim = Math.max(size.x, size.y, size.z);
        cameraRadius = maxDim * 2.5;
        targetRotation = { x: 0.3, y: 0.8 };
        rotation = { x: 0.3, y: 0.8 };

        // Load sound
        loadSound(filename);

        msg.style.display = "none";
        updateModelCounter();
        highlightSelectedTile();
      } catch (err) {
        console.error('Load error:', err);
        msg.textContent = `Failed to load ${filename}.`;
      }
    }

    function loadSound(modelFilename) {
      if (currentSound) {
        currentSound.pause();
        currentSound = null;
      }
      const baseName = modelFilename.split('/').pop().replace('.glb', '');
      const soundUrl = `sounds/${baseName}.mp3`;
      currentSound = new Audio(soundUrl);
      currentSound.preload = 'auto'; // Preload for quick play
    }

    function playSound() {
      if (currentSound) {
        currentSound.currentTime = 0; // Restart if already playing
        currentSound.play().catch(err => console.error('Sound play error:', err));
      }
    }

    function handleClick(event) {
      // Normalize pointer position
      pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
      pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(pointer, camera);

      const intersects = raycaster.intersectObjects(scene.children, true);

      if (intersects.length > 0 && intersects[0].object.isMesh) { // Hit a mesh in the model
        playSound();
      }
    }

    function updateModelCounter() {
      document.getElementById('modelCounter').textContent =
        `${getDisplayName(MODEL_FILES[currentModelIndex])} (${currentModelIndex + 1} of ${MODEL_FILES.length})`;
    }

    function getDisplayName(filename) {
      const name = filename.split('/').pop().replace('.glb', '');
      return name.replace(/[-_]/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
    }

    function getThumbnailUrl(glbFilename) {
      const baseName = glbFilename.split('/').pop().replace('.glb', '');
      return `models/thumbnails/${baseName}.jpg`;
    }

    // Fetch model list from /models/
    async function init() {
      msg.textContent = 'Fetching model list…';
      try {
        const response = await fetch('https://api.github.com/repos/pneumatic-steel/3D-viewer/contents/models');
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const data = await response.json();

        MODEL_FILES = data
          .filter(item => item.type === 'file' && item.name.toLowerCase().endsWith('.glb'))
          .map(item => `models/${item.name}`)
          .sort((a, b) => a.localeCompare(b));

        if (MODEL_FILES.length === 0) {
          msg.textContent = 'No .glb models found in /models/.';
          msg.style.display = 'grid';
          return;
        }

        buildMenu();
        currentModelIndex = 0;
        await loadModel(MODEL_FILES[currentModelIndex]);
      } catch (error) {
        console.error(error);
        msg.textContent = 'Failed to fetch model list.';
      }
    }

    // Build the thumbnail menu
    function buildMenu() {
      menuGrid.innerHTML = '';
      MODEL_FILES.forEach((filename, index) => {
        const tile = document.createElement('div');
        tile.className = 'menuTile';
        if (index === currentModelIndex) tile.classList.add('selected');

        const img = document.createElement('img');
        img.src = getThumbnailUrl(filename);
        img.onerror = () => { img.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg=='; }; // fallback
        img.alt = getDisplayName(filename);

        const span = document.createElement('span');
        span.textContent = getDisplayName(filename);

        tile.appendChild(img);
        tile.appendChild(span);

        tile.addEventListener('click', async () => {
          currentModelIndex = index;
          await loadModel(filename);
          menuPanel.style.display = 'none';
        });

        menuGrid.appendChild(tile);
      });
    }

    function highlightSelectedTile() {
      document.querySelectorAll('.menuTile').forEach((tile, i) => {
        tile.classList.toggle('selected', i === currentModelIndex);
      });
      updateModelCounter();
    }

    // Menu controls
    menuButton.addEventListener('click', () => {
      menuPanel.style.display = 'flex';
      buildMenu();
    });

    menuClose.addEventListener('click', () => {
      menuPanel.style.display = 'none';
    });

    // Other UI
    let autoRotate = true;
    const btnRotate = document.getElementById("toggleRotate");
    const btnReset = document.getElementById("reset");
    const speed = document.getElementById("speed");

    btnRotate.addEventListener("click", () => {
      autoRotate = !autoRotate;
      btnRotate.textContent = `Auto-rotate: ${autoRotate ? "ON" : "OFF"}`;
    });

    btnReset.addEventListener("click", () => {
      if (pivot) {
        const box = new THREE.Box3().setFromObject(pivot);
        const size = box.getSize(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z);
        cameraRadius = maxDim * 2.5;
        targetRotation = { x: 0.3, y: 0.8 };
        rotation = { x: 0.3, y: 0.8 };
      }
    });

    // Render loop
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      updateCamera();

      if (pivot && autoRotate && !isDragging) {
        const dt = clock.getDelta();
        pivot.rotation.y += dt * parseFloat(speed.value);
      }

      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    init();
  </script>
</body>
</html>
